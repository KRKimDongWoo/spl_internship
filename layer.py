
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/layer.ipynb
from torch import nn, cat, Tensor

class Flatten(nn.Module):
    def forward(self, x): return x.view(x.size(0), -1)

class Concat(nn.Module):
    def forward(self, x):
        if isinstance(x, Tensor):
            return x
        else:
            return cat(x, 0)

class Add(nn.Module):
    def forward(self, x):
        if isinstance(x, Tensor):
            return x
        elif isinstance(x, list):
            return sum(x)

class Generator(nn.Module):
    def __init__(self, ts):
        super().__init__()
        self.sequence = []
        self.ts = ts
        self.layers = nn.ModuleDict()

        index = 0
        for layer, input, output in ts:
            self.layers[str(index)] = layer
            self.sequence.append((str(index), input, output))
            index = index + 1

    def forward(self, x):
        value = {1: x}
        for layer, input, output in self.sequence:
            if isinstance(input, list):
                value[output] = self.layers[layer]([value[i] for i in input])
            else:
                value[output] = self.layers[layer](value[input])
        return value[2]

#         self.values[1] = x # Input node
#         for id in self.ts:
#             edge = self.edges[id]
#             try:
#                 ori = self.values[edge.dest]
#             except KeyError as e:
#                 ori = None
#
#             new = self._module[id](self.values[edge.src])
#             self.values[edge.dest] = self.nodes[edge.dest].method(ori, new)
