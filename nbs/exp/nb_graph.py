
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nb/graph.ipynb
import torch
from math import ceil
from exp.nb_layer import *
from exp.nb_graph_transformer import *
from graphviz import Digraph

NOISE_RATIO = 1e-4

class Graph:
    def __init__(self, input_shape, output_shape):
        self.nodes={}
        self.edges={}
        self._node_index = 0
        self._edge_index = 0

        self.input = self.add_node(input_shape)
        self.output = self.add_node(output_shape)


    def add_node(self, shape, multi_input=False, layer=None):
        node = Node(shape, multi_input, layer)
        self._node_index = self._node_index + 1
        self.nodes[self._node_index] = node
        return self._node_index

    def insert_node(self, src, multi_input=False, layer=None):
        if multi_input:
            new_node = self.add_node(self.nodes[src].shape, multi_input, layer)
            self.nodes[new_nodede].out_edge = self.nodes[src].out_edge
            for edge in self.nodes[new_node].out_edge:
                self.edges[edge].src = new_node
            self.nodes[src].out_edge = []
            self.add_edge(src, new_node, identical=True)
        else:
            # add new node
            new_node = self.add_node(shape=self.nodes[src].shape)

            # redirect edges
            self.nodes[new_node].out_edge = self.nodes[src].out_edge
            for edge in self.nodes[new_node].out_edge:
                self.edges[edge].src = new_node
            self.nodes[src].out_edge = []
            self.add_edge(src, new_node, layer=layer, identical=False)

        return new_node

    def add_edge(self, src, dest, layer=None, identical=False):
        edge = Edge(src, dest, layer, identical)

        self._edge_index = self._edge_index + 1
        self.edges[self._edge_index] = edge

        self.nodes[src].add_out_edge(self._edge_index)
        self.nodes[dest].add_in_edge(self._edge_index)

        return self._edge_index

    def visualize(self, filename, path):
        digraph = Digraph(comment="Model")
        for node in self.nodes:
            digraph.node(str(node), label=str(node) + str(self.nodes[node].shape))
        for id in self.edges:
            edge = self.edges[id]
            digraph.edge(str(edge.src), str(edge.dest), label="id" if edge.identical else str(edge.as_layer()))

        digraph.format='svg'
        digraph.filename=filename
        digraph.directory=path
        digraph.render(view=False)

    def _node_as_layer(self, id):
        node = self.nodes[id]
        layer = node.layer()
        inputs = []

        for edge_id in node.in_edge:
            inputs.append(self.edges[edge_id].src)

        return (layer, inputs, id)

    def _reverse_traversal(self, id, visited):
#         print('traveling on {}'.format(id))
        ts = []
        visited[id] = True
#         print('current visited: {}'.format(visited))
        for edge_id in self.nodes[id].in_edge:
            edge = self.edges[edge_id]
            if not visited[edge.src]: ts.extend(self._reverse_traversal(edge.src, visited))
            if not edge.identical: ts.append((edge.as_layer(), edge.src, edge.dest))
        if self.nodes[id].multi_input:
            ts.append((self._node_as_layer(id)))
#         print('on {}: {}'.format(id, ts))
        return ts

    def generate_model(self):
        visited = {}
        for key in self.nodes.keys():
            visited[key] = False

        ts = self._reverse_traversal(2, visited)
#         print(ts)
        return Generator(ts)

class Node:
    def __init__(self, shape, multi_input=False, layer=None):
        self.shape = shape
        self.multi_input = multi_input
        self.in_edge = []
        self.out_edge = []
        self.layer = layer

    def add_in_edge(self, edge):
        self.in_edge.append(edge)

    def add_out_edge(self, edge):
        self.out_edge.append(edge)

    def num_output(self):
        return len(self.out_edge)

    def set_shape(self, shape):
        self.shape = shape

class Edge:
    def __init__(self, src, dest, layer, identical=False):
        self.src = src
        self.dest = dest
        self.identical = identical
        if not identical:
            self.layer = layer

    def as_layer(self):
        return self.layer

    def updated_src(self, in_shape, expanded=[]):
        pass

    def updated_dest(self, out_shape, expanded=[]):
        pass