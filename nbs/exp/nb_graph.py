
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nb/graph.ipynb
import torch
from math import ceil
from exp.nb_layer import *
from exp.nb_graph_transformer import *
from graphviz import Digraph

NOISE_RATIO = 1e-4

class Graph:
    def __init__(self, input_shape, output_shape):
        self.nodes={}
        self.edges={}
        self._node_index = 0
        self._edge_index = 0

        self.input = self.add_node(input_shape)
        self.output = self.add_node(output_shape)


    def add_node(self, shape, multi_input=False, layer=None):
        node = Node(shape, multi_input, layer)
        self._node_index = self._node_index + 1
        self.nodes[self._node_index] = node
        return self._node_index

    def insert_node(self, src, multi_input=False, layer=None):
        if multi_input:
            new_node = self.add_node(self.nodes[src].shape, multi_input, layer)
            self.nodes[new_nodede].out_edge = self.nodes[src].out_edge
            for edge in self.nodes[new_node].out_edge:
                self.edges[edge].src = new_node
            self.nodes[src].out_edge = []
            self.add_edge(src, new_node, identical=True)
        else:
            # add new node
            new_node = self.add_node(shape=self.nodes[src].shape)

            # redirect edges
            self.nodes[new_node].out_edge = self.nodes[src].out_edge
            for edge in self.nodes[new_node].out_edge:
                self.edges[edge].src = new_node
            self.nodes[src].out_edge = []
            self.add_edge(src, new_node, layer=layer, identical=False)

        return new_node

    def add_edge(self, src, dest, layer=None, identical=False):
        edge = Edge(src, dest, layer, identical)

        self._edge_index = self._edge_index + 1
        self.edges[self._edge_index] = edge

        self.nodes[src].add_out_edge(self._edge_index)
        self.nodes[dest].add_in_edge(self._edge_index)

        return self._edge_index

    def visualize(self, filename, path):
        digraph = Digraph(comment="Model")
        for node in self.nodes:
            digraph.node(str(node), label=str(node) + str(self.nodes[node].shape))
        for id in self.edges:
            edge = self.edges[id]
            digraph.edge(str(edge.src), str(edge.dest), label="id" if edge.identical else str(edge.as_layer()))

        digraph.format='svg'
        digraph.filename=filename
        digraph.directory=path
        digraph.render(view=False)

    def _node_as_layer(self, id):
        node = self.nodes[id]
        layer = node.layer()
        inputs = []

        for edge_id in node.in_edge:
            inputs.append(self.edges[edge_id].src)

        return (layer, inputs, id)

    def _reverse_traversal(self, id, visited):
#         print('traveling on {}'.format(id))
        ts = []
        visited[id] = True
#         print('current visited: {}'.format(visited))
        for edge_id in self.nodes[id].in_edge:
            edge = self.edges[edge_id]
            if not visited[edge.src]: ts.extend(self._reverse_traversal(edge.src, visited))
            if not edge.identical: ts.append((edge.as_layer(), edge.src, edge.dest))
        if self.nodes[id].multi_input:
            ts.append((self._node_as_layer(id)))
#         print('on {}: {}'.format(id, ts))
        return ts

    def generate_model(self):
        visited = {}
        for key in self.nodes.keys():
            visited[key] = False

        ts = self._reverse_traversal(2, visited)
#         print(ts)
        return Generator(ts)

class Node:
    def __init__(self, shape, multi_input=False, layer=None):
        self.shape = shape
        self.multi_input = multi_input
        self.in_edge = []
        self.out_edge = []
        self.layer = layer

    def add_in_edge(self, edge):
        self.in_edge.append(edge)

    def add_out_edge(self, edge):
        self.out_edge.append(edge)

    def num_output(self):
        return len(self.out_edge)

    def set_shape(self, shape):
        self.shape = shape

class Edge:
    def __init__(self, src, dest, layer, identical=False):
        self.src = src
        self.dest = dest
        self.identical = identical
        if not identical:
            self.layer = layer

    def as_layer(self):
        return self.layer

    def updated_src(self, in_shape, expanded=[]):
        pass

    def updated_dest(self, out_shape, expanded=[]):
        pass

def add_noise(weight):
    noise_range = np.ptp(weight.flatten()) * NOISE_RATIO
    noise = np.random.uniform(-noise_range/2.0, noise_range/2.0, weight.shape)
    return np.add(weight, noise)

class FlattenEdge(Edge):
    def __init__(self, src, dest):
        super(FlattenEdge, self).__init__(src, dest, layer=Flatten, identical=False)

    def updated_src(self, in_shape, expanded=[]):
        total = 1
        nf = in_shape[0]
        for i in in_shape:
            total = total * i
        out_shape = (total,)
        feature_size = total // nf

        new_expanded = []
        for o, c in expanded:
            origin = range(o*feature_size, (o+1)*feature_size)
            copied = range(c*feature_size, (c+1)*feature_size)
            new_expanded.extend((o, c) for o, c in zip(origin, copied))

        return out_shape, new_expanded

class BatchNormEdge(Edge):

    def __init__(self, src, dest, num_features):
        self.args = {
            'num_features': num_features,
        }
        super(BatchNormEdge, self).__init__(src,
                                          dest,
                                          layer=torch.nn.BatchNorm2d(**self.args),
                                          identical=False)

    def updated_src(self, in_shape, expanded=[]):

        nf = in_shape[0]
        extended_params = {
            'weight': torch.Tensor(nf),
            'bias': torch.Tensor(nf)
        }

        # Get original parameters.
        params = dict((name, value.data) for (name, value) in self.layer.named_parameters())

        # Expand original parameters
        for key in params.keys():
            extended_params[key][:len(params[key])] = params[key]
            for o, c in expanded:
                extended_params[key][c] = extended_params[key][o]
            extended_params[key] = add_noise(extended_params[key]).float()

        # Update argument
        self.args['num_features'] = nf

        # Update the layer
        new_layer = torch.nn.BatchNorm2d(**self.args)
        new_layer.weight.data = extended_params['weight']
        new_layer.bias.data = extended_params['bias']
        self.layer = new_layer

        # Generate new output shape
        out_shape = in_shape
        return out_shape, expanded

    def updated_dest(self, out_shape, expanded=[]):
        return out_shape, expanded


class ReluEdge(Edge):
    def __init__(self, src, dest, num_features):
        self.args = {
        }
        super(ReluEdge, self).__init__(src,
                                       dest,
                                       layer=torch.nn.ReLU(),
                                       identical=False)

    def updated_src(self, in_shape, expanded=[]):
        return in_shape, expanded

    def updated_dest(self, out_shape, expanded=[]):
        return out_shape, expanded


class PoolingEdge(Edge):
    def __init__(self):
        pass

    def _set_args(self, kernel_size, stride, padding):
        stride = kernel_size if stride == None else stride
        stride = (stride, stride) if isinstance(stride, int) else stride
        kernel_size = (kernel_size, kernel_size) if isinstance(kernel_size, int) else kernel_size
        padding = (padding, padding) if isinstance(padding, int) else padding

        self.args = {
            'kernel_size': kernel_size,
            'stride': stride,
            'padding': padding,
            'ceil_mode': True
        }

    def updated_src(self, in_shape, expanded=[]):
        if len(in_shape) != 3: raise Exception('Unsuitable input shape')

        attr = zip(in_shape[1:],
                   self.args['kernel_size'],
                   self.args['stride'],
                   self.args['padding'])
        out_shape = (in_shape[0],) + tuple(self.calculate_output(x, ks, st, pd)
                                           for x, ks, st, pd in attr)

        return out_shape, expanded

    def calculate_output(self, value, ks, st, pd):
        return ceil((value + 2 * pd - ks) / st + 1)

class MaxPoolingEdge(PoolingEdge):
    def __init__(self, src, dest, kernel_size, stride=None, padding=0):
        self._set_args(kernel_size=kernel_size, stride=stride, padding=padding)
        super(PoolingEdge, self).__init__(src,
                                          dest,
                                          layer=torch.nn.MaxPool2d(**self.args),
                                          identical=False)

class AvgPoolingEdge(PoolingEdge):
    def __init__(self, src, dest, kernel_size, stride=None, padding=0):
        self._set_args(kernel_size=kernel_size, stride=stride, padding=padding)
        super(PoolingEdge, self).__init__(src,
                                          dest,
                                          layer=torch.nn.AvgPool2d(**self.args),
                                          identical=False)

class LinearEdge(Edge):
    def __init__(self, src, dest, in_features, out_features, bias=True):
        self.args = {
            'in_features': in_features,
            'out_features': out_features,
            'bias': bias
        }
        super(LinearEdge, self).__init__(src,
                                         dest,
                                         layer=torch.nn.Linear(**self.args),
                                         identical=False)

    def updated_src(self, in_shape, expanded=[]):
        ni = in_shape[0]

        # Get original parameters
        params = dict((name, value.data) for (name, value) in self.layer.named_parameters())

        # Expand original parameters
        expanded_weight = torch.Tensor(self.args['out_features'], ni)
        expanded_weight[:,:self.args['in_features']] = params['weight']
        for o, c in expanded:
            expanded_weight[:,c] = params['weight'][:,o]
        expanded_weight = add_noise(expanded_weight).float()

        # Update the args
        self.args['in_features'] = ni

        # Update the layer
        new_layer = torch.nn.Linear(**self.args)
        new_layer.weight.data = expanded_weight
        new_layer.bias.data = params['bias']
        self.layer = new_layer

        # Generate new output shape
        out_shape = (self.args['out_features'],)
        return out_shape, []