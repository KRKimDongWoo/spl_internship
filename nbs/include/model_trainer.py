
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nb/model_trainer.ipynb
import os

from fastai.callbacks import EarlyStoppingCallback
from fastai.vision import Learner, partial, accuracy, nn
from fastai.utils.mod_display import progress_disabled_ctx

class ValueHolder():
    def __init__(self):
        self._value = 0

    def update_value(self, value):
        if self._value < value: self._value = value

    def reset(self):
        self._value = 0

    @property
    def value(self):
        return self._value

class ValueTrackingCallback(EarlyStoppingCallback):

    def __init__(self, learn:Learner, value_holder:ValueHolder, monitor:str='accuracy',
                 mode:str='auto', min_delta:int=0, patience:int=0):
        super().__init__(learn, monitor, mode, min_delta, patience)
        self.value_holder = value_holder

    def on_train_begin(self, **kwargs):
        self.value_holder.reset()
        super().on_train_begin(**kwargs)

    def on_train_end(self, **kwargs):
        super().on_train_end(**kwargs)
        self.value_holder.update_value(self.best)

class Trainer():
    def __init__(self, path, data, loss_func=None, metrics=None, monitor='accuracy'):
        self.data = data
        self.loss_func = nn.CrossEntropyLoss() if loss_func == None else loss_func
        self.metrics = [accuracy] if metrics==None else metrics
        self.monitor = monitor

        self.accuracy = ValueHolder()
        self._model_num = 0

        if not os.path.exists(path):
            os.mkdir(path)
        self.path = os.path.join(os.getcwd(), path)

    def train(self, graph, max_epoch=100, min_delta=0, patience=0):
        model_num = self._model_num
        self._model_num = self._model_num + 1
        learn = Learner(self.data, graph.generate_model(), loss_func=self.loss_func, metrics=self.metrics,
                        callback_fns=[partial(ValueTrackingCallback,
                                              value_holder=self.accuracy,
                                              monitor=self.monitor,
                                              min_delta=min_delta,
                                              patience=patience)])
        progress_disabled_ctx(learn)
        learn.fit(max_epoch)
        print(f'Saving model {model_num}...', end='')
        graph.save(os.path.join(self.path, str(model_num)))
        print(' Done!')
        print(f'Model number: {model_num}\nBest accuracy: {self.accuracy.value}')
        return model_num, self.accuracy.value.item()