
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nb/graph.ipynb
from .edges import *
from ..layer import Concat, Add
from ..generator import Generator
from .edges import IdenticalEdge
from graphviz import Digraph
from pickle import load, dump
from os import mkdir, path

LAYER_NAME = {
    'conv': ConvEdge,
    'linear': LinearEdge,
    'batchnorm': BatchNormEdge,
    'relu': ReluEdge,
    'maxpooling': MaxPoolingEdge,
    'avgpooling': AvgPoolingEdge,
    'adaptivemaxpooling': AdaptiveMaxPoolingEdge,
    'adaptiveavgpooling': AdaptiveAvgPoolingEdge,
    'identical': IdenticalEdge,
    'flatten': FlattenEdge,
    'dropout': DropoutEdge,
    'add': Add,
    'concat': Concat,
}

class Graph:
    def __init__(self, input_shape, output_shape):
        self.nodes={}
        self.edges={}
        self._node_index = 0
        self._edge_index = 0

        self.input = self.add_node(input_shape)
        self.output = self.add_node(output_shape)

        self.nodes[self.input].rank = 0


    def add_node(self, shape, multi_input=False, layer=None):
        node = Node(shape, multi_input, layer)
        self._node_index = self._node_index + 1
        self.nodes[self._node_index] = node
        return self._node_index

    def insert_node(self, src, shape=None, multi_input=False, edge=None, layer=None):
        shape = self.nodes[src].shape if shape==None else shape
        if multi_input:
            if layer == None: raise Exception('Multi-input node requires layer.')

            # Create new node
            new_node = self.add_node(shape, multi_input, layer)

            # Redirect edges
            self.nodes[new_node].out_edge = self.nodes[src].out_edge
            for edge in self.nodes[new_node].out_edge:
                self.edges[edge].src = new_node
            self.nodes[src].out_edge = []

            # Add edge between new and src node
            edge = IdenticalEdge(src, new_node)
            self.add_edge(edge)
        else:
            # Add new node
            new_node = self.add_node(shape=shape)

            # Redirect edges
            self.nodes[new_node].out_edge = self.nodes[src].out_edge
            for edge_id in self.nodes[new_node].out_edge:
                self.edges[edge_id].src = new_node
            self.nodes[src].out_edge = []

            # Attach edge between src and new node.
            edge.src = src
            edge.dest = new_node
            self.add_edge(edge)

        return new_node

    def add_edge(self, edge):
        self._edge_index = self._edge_index + 1
        self.edges[self._edge_index] = edge

        src_node = self.nodes[edge.src]
        dest_node = self.nodes[edge.dest]

        src_node.add_out_edge(self._edge_index)
        dest_node.add_in_edge(self._edge_index)

        if dest_node.multi_input:
            dest_node.rank = max(dest_node.rank, src_node.rank + 1)
        else:
            dest_node.rank = src_node.rank

        return self._edge_index

    def visualize(self, filename, path):
        digraph = Digraph(comment="Model")
        for id in self.nodes:
            node = self.nodes[id]
            digraph.node(str(id), label=f'id:{id} rank:{node.rank} shape: {node.shape}')
        for id in self.edges:
            edge = self.edges[id]
            digraph.edge(str(edge.src), str(edge.dest), label="id" if edge.identical else str(edge.as_layer()))

        digraph.format='svg'
        digraph.filename=filename
        digraph.directory=path
        digraph.render(view=False)

    def save(self, dir_name, graph_data={}, weight_data={}):
        if not path.exists(dir_name):
            mkdir(dir_name)
        graph = open(path.join(dir_name, 'graph'), 'wb+')
        weight = open(path.join(dir_name, 'weight'), 'wb+')

        graph_data['input'] = self.input
        graph_data['output'] = self.output
        graph_data['node'] = dict()
        graph_data['edge'] = dict()
        graph_data['last_node'] = self._node_index
        graph_data['last_edge'] = self._edge_index

        for node_id in self.nodes:
            node = self.nodes[node_id]
            graph_data['node'][node_id] = node.node_args

        for edge_id in self.edges:
            edge = self.edges[edge_id]
            graph_data['edge'][edge_id] = edge.edge_args
            if edge.edge_args['layer'] == 'identical': continue
            weight_data[edge_id] = dict(edge.layer.named_parameters())

        dump(graph_data, graph)
        dump(weight_data, weight)

    def load(self, dir_name):
        if not path.exists(dir_name):
            raise Exception('Cannot find module.')
        graph = open(path.join(dir_name, 'graph'), 'rb')
        weight = open(path.join(dir_name, 'weight'), 'rb')
        graph_data = load(graph)
        weight_data = load(weight)

        self.nodes = {}
        self.edges = {}
        self._node_index = 0
        self._edge_index = 0

        key_to_id = {}

        for key in graph_data['node'].keys():
            node = graph_data['node'][key]
            if 'layer' in node:
                id = self.add_node(node['shape'], True, LAYER_NAME[node['layer']])
            else:
                id = self.add_node(node['shape'])
            self.nodes[id].rank = node['rank']
            key_to_id[key] = id

        for key in graph_data['edge'].keys():
            edge = graph_data['edge'][key]
            edge_type = LAYER_NAME[edge['layer']]
            new_edge = edge_type(key_to_id[edge['src']],
                                 key_to_id[edge['dest']],
                                 **edge['args'])
            self.add_edge(new_edge)
            if key in weight_data:
                new_edge.set_weight(**weight_data[key])

        self.input = key_to_id[graph_data['input']]
        self.output = key_to_id[graph_data['output']]
        return graph_data, weight_data, key_to_id

    def _node_as_layer(self, id):
        node = self.nodes[id]
        layer = node.layer()
        inputs = []

        for edge_id in node.in_edge:
            inputs.append(self.edges[edge_id].src)

        return (layer, inputs, id)

    def _update_node_shape(self, id):
        node = self.nodes[id]
        if node.multi_input:
            if node.layer is Concat:
                method = lambda x, y: y if x == None else (x[0] + y[0],) + x[1:]
            else:
                method = lambda x, y: y
            shape = None
            for edge_id in node.in_edge:
                edge = self.edges[edge_id]
                shape = method(shape, self.nodes[edge.src].shape)
        else:
            edge = self.edges[node.in_edge[0]]
            in_shape = self.nodes[edge.src].shape
            shape = edge.calculate_output(in_shape)
        self.nodes[id].shape = shape

    def _reverse_traversal(self, id, visited):
        ts = []
        visited[id] = True
        for edge_id in self.nodes[id].in_edge:
            edge = self.edges[edge_id]
            if not visited[edge.src]: ts.extend(self._reverse_traversal(edge.src, visited))
            if not edge.identical: ts.append((edge.as_layer(), edge.src, edge.dest))
        if self.nodes[id].multi_input:
            ts.append((self._node_as_layer(id)))
        return ts

    def generate_model(self):
        visited = {}
        for key in self.nodes.keys():
            visited[key] = False

        ts = self._reverse_traversal(2, visited)
        return Generator(ts)

class Node:
    def __init__(self, shape, multi_input=False, layer=None):
        self.shape = shape
        self.multi_input = multi_input
        self.in_edge = []
        self.out_edge = []
        self.layer = layer
        self.rank = -1

    def add_in_edge(self, edge):
        self.in_edge.append(edge)

    def add_out_edge(self, edge):
        self.out_edge.append(edge)

    def num_output(self):
        return len(self.out_edge)

    def set_shape(self, shape):
        self.shape = shape

    @property
    def node_args(self):
        args = {'shape': self.shape, 'rank': self.rank}
        if self.multi_input:
            if self.layer is Add:
                args['layer'] = 'add'
            elif self.layer is Concat:
                args['layer'] = 'concat'
            else:
                args['layer'] = None
        return args